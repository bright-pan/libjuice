<!DOCTYPE html>
<!--
 *  Copyright (c) 2022 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
-->
<html>

<head>

    <meta charset="utf-8">
    <meta name="description" content="WebRTC code samples">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
    <meta itemprop="description" content="Client-side WebRTC code samples">
    <meta itemprop="image" content="../../../images/webrtc-icon-192x192.png">
    <meta itemprop="name" content="WebRTC code samples">
    <meta name="mobile-web-app-capable" content="yes">
    <meta id="theme-color" name="theme-color" content="#ffffff">

    <base target="_blank">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700" rel="stylesheet" type="text/css">
    <script src="http://192.168.1.186:8000/js/sdp.js"></script>
    <script src="http://192.168.1.186:8000/js/mqtt.min.js"></script>
    <title>Transmit text (between two tabs)</title>
    <style>
.hidden {
  display: none;
}

.highlight {
  background-color: #eee;
  font-size: 1.2em;
  margin: 0 0 30px 0;
  padding: 0.2em 1.5em;
}

.warning {
  color: red;
  font-weight: 400;
}

@media screen and (min-width: 1000px) {
  /* hack! to detect non-touch devices */
  div#links a {
    line-height: 0.8em;
  }
}

audio {
  max-width: 100%;
}

body {
  font-family: 'Roboto', sans-serif;
  font-weight: 300;
  margin: 0;
  padding: 1em;
  word-break: break-word;
}

button {
  background-color: #d84a38;
  border: none;
  border-radius: 2px;
  color: white;
  font-family: 'Roboto', sans-serif;
  font-size: 0.8em;
  margin: 0 0 1em 0;
  padding: 0.5em 0.7em 0.6em 0.7em;
}

button:active {
  background-color: #cf402f;
}

button:hover {
  background-color: #cf402f;
}

button[disabled] {
  color: #ccc;
}

button[disabled]:hover {
  background-color: #d84a38;
}

canvas {
  background-color: #ccc;
  max-width: 100%;
  width: 100%;
}

textarea {
    width: 400px;
}

code {
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
}

div#container {
  margin: 0 auto 0 auto;
  max-width: 60em;
  padding: 1em 1.5em 1.3em 1.5em;
}

div#links {
  padding: 0.5em 0 0 0;
}

h1 {
  border-bottom: 1px solid #ccc;
  font-family: 'Roboto', sans-serif;
  font-weight: 500;
  margin: 0 0 0.8em 0;
  padding: 0 0 0.2em 0;
}

h2 {
  color: #444;
  font-weight: 500;
}

h3 {
  border-top: 1px solid #eee;
  color: #666;
  font-weight: 500;
  margin: 10px 0 10px 0;
  white-space: nowrap;
}

li {
  margin: 0 0 0.4em 0;
}

html {
  /* avoid annoying page width change
  when moving from the home page */
  overflow-y: scroll;
}

img {
  border: none;
  max-width: 100%;
}

input[type=radio] {
  position: relative;
  top: -1px;
}

p {
  color: #444;
  font-weight: 300;
}

p#data {
  border-top: 1px dotted #666;
  font-family: Courier New, monospace;
  line-height: 1.3em;
  max-height: 1000px;
  overflow-y: auto;
  padding: 1em 0 0 0;
}

p.borderBelow {
  border-bottom: 1px solid #aaa;
  padding: 0 0 20px 0;
}

section p:last-of-type {
  margin: 0;
}

section {
  border-bottom: 1px solid #eee;
  margin: 0 0 30px 0;
  padding: 0 0 20px 0;
}

section:last-of-type {
  border-bottom: none;
  padding: 0 0 1em 0;
}

select {
  margin: 0 1em 1em 0;
  position: relative;
  top: -1px;
}

h1 span {
  white-space: nowrap;
}

a {
  color: #1D6EEE;
  font-weight: 300;
  text-decoration: none;
}

h1 a {
  font-weight: 300;
  margin: 0 10px 0 0;
  white-space: nowrap;
}

a:hover {
  color: #3d85c6;
  text-decoration: underline;
}

a#viewSource {
  display: block;
  margin: 1.3em 0 0 0;
  border-top: 1px solid #999;
  padding: 1em 0 0 0;
}

div#errorMsg p {
  color: #F00;
}

div#links a {
  display: block;
  line-height: 1.3em;
  margin: 0 0 1.5em 0;
}

div.outputSelector {
  margin: -1.3em 0 2em 0;
}

p.description {
  margin: 0 0 0.5em 0;
}

strong {
  font-weight: 500;
}

textarea {
  resize: none;
  font-family: 'Roboto', sans-serif;
}

video {
  background: #222;
  margin: 0 0 20px 0;
  --width: 100%;
  width: var(--width);
  height: calc(var(--width) * 0.75);
}

ul {
  margin: 0 0 0.5em 0;
}

fieldset {
  margin: 0 0 1em 0;
}

fieldset > select {
  margin-top: 1em;
}

@media screen and (max-width: 650px) {
  .highlight {
    font-size: 1em;
    margin: 0 0 20px 0;
    padding: 0.2em 1em;
  }

  h1 {
    font-size: 24px;
  }
}

@media screen and (max-width: 550px) {
  button:active {
    background-color: darkRed;
  }

  h1 {
    font-size: 22px;
  }
}

@media screen and (max-width: 450px) {
  h1 {
    font-size: 20px;
  }
}
video {
  margin: 0 10px 0 0;
  width: calc(50% - 7px);
}

video:last-of-type {
  margin-right: 0;
}

@media screen and (max-width: 400px) {
  video {
    margin: 0 5px 20px 0;
    width: calc(50% - 5px);
  }
}
      </style>
</head>

<body>
    <div id="container">
        <h1>WebRTC Transmit text</h1>
        <video id="remotevideo" playsinline="" controls="" autoplay=""></video>
        <video id="localvideo" playsinline="" controls="" hidden></video>
        <h2>Control</h3>
        <button id="initButton">本地初始化</button>
        <button id="startButton" disabled>远程呼叫</button>
        <button id="closeButton" disabled>停止</button>
        <button id="sendButton" disabled>发送</button>
        <button id="switchButton">ID互换</button>
        <h2>Local ID</h3>
        <textarea id="local_id"></textarea>
        <h2>Remote ID</h3>
        <textarea id="remote_id"></textarea>
        <h2>Send</h2>
        <textarea id="dataChannelSend" disabled placeholder="请输入要发送得文本...."></textarea>
        <h2>Receive</h2>
        <textarea id="dataChannelReceive" disabled></textarea>
        <script>

            // const clientId = 'mqtt_' + Math.random().toString(16).substr(2, 8)
            let remotevideo = document.getElementById("remotevideo");
            remotevideo.onplay = function() {console.log("Play for remotevideo");};
            let localvideo = document.getElementById("localvideo");
            localvideo.onplay = function() {console.log("Play for localvideo");};


            local_view = document.getElementById('local_id');
            local_view.value = "D-15JEvX-2Q3rY3Uk-7C:DF:A1:FF:FF:FF"
            remote_view = document.getElementById('remote_id');
            remote_view.value = "D-15JEvX-2Q3rY3Uk-7C:DF:A1:F2:13:18"

            const host = 'wss://iot.test.funlink.cloud:8183/mqtt'
            // const host = 'ws://122.114.60.74:8083/mqtt'

            // const host = 'ws://192.168.12.193:8080/mqtt'
            // const host = 'ws://mqtt.eclipseprojects.io:80/mqtt'

            const webrtc_topic_prefix = 'webrtc/'

            const configuration = {
                // sdpSemantics: 'plan-b',
                bundlePolicy: 'max-bundle',
                iceServers: [{
                    url: 'turn:test.funlink.cloud:3478',
                    // url: 'turn:192.168.1.186:3478',
                    username: 'username1',
                    credential: 'password1'
                }]
                // iceServers: [
                //         {
                //             urls: "stun:stun.relay.metered.ca:80",
                //         },
                //         {
                //             urls: "turn:a.relay.metered.ca:80",
                //             username: "582e76da4d1dca59a632a28c",
                //             credential: "8spay3NSF+9uslHA",
                //         },
                //         {
                //             urls: "turn:a.relay.metered.ca:80?transport=tcp",
                //             username: "582e76da4d1dca59a632a28c",
                //             credential: "8spay3NSF+9uslHA",
                //         },
                //         {
                //             urls: "turn:a.relay.metered.ca:443",
                //             username: "582e76da4d1dca59a632a28c",
                //             credential: "8spay3NSF+9uslHA",
                //         },
                //         {
                //             urls: "turn:a.relay.metered.ca:443?transport=tcp",
                //             username: "582e76da4d1dca59a632a28c",
                //             credential: "8spay3NSF+9uslHA",
                //         },
                //     ]
            };

            let client = null;

            function remote_PostMessage(m) {
                client.publish(webrtc_topic_prefix + remote_view.value, JSON.stringify(m), { qos: 0, retain: false })
            }

            const initButton = document.getElementById('initButton');
            const switchButton = document.getElementById('switchButton');
            const startButton = document.getElementById('startButton');
            const closeButton = document.getElementById('closeButton');
            // const setSdpButton = document.getElementById('setSdpButton');
            const sendButton = document.getElementById('sendButton');

            sendButton.onclick = sendData;

            const dataChannelSend = document.querySelector('textarea#dataChannelSend');
            const dataChannelReceive = document.querySelector('textarea#dataChannelReceive');
            const sdp_receive = document.querySelector('textarea#sdp');

            let startTime;
            let pc;
            let sendChannel;
            let receiveChannel;
            const constraints = window.constraints = {
                audio: true,
                video: false
            };
            let localStream;
            const offerOptions = {
                // New spec states offerToReceiveAudio/Video are of type long (due to
                // having to tell how many "m" lines to generate).
                // http://w3c.github.io/webrtc-pc/#idl-def-RTCOfferAnswerOptions.
                offerToReceiveAudio: 1,
                offerToReceiveVideo: 1,
                // iceRestart: restartInput.checked,
                // voiceActivityDetection: vadInput.checked
            };
            // let offer_sdp;


            remotevideo.addEventListener('loadedmetadata', function() {
                console.log(`Remote video videoWidth: ${this.videoWidth}px,  videoHeight: ${this.videoHeight}px`);
                remotevideo_audio_tracks = this.srcObject.getAudioTracks();
                if (remotevideo_audio_tracks.length == 0 && pc.getReceivers()[0].track.kind == 'audio') {
                    this.srcObject.addTrack(pc.getReceivers()[0].track)
                }
            });
            remotevideo.addEventListener('resize', () => {
                console.log(`Remote video size changed to ${remotevideo.videoWidth}x${remotevideo.videoHeight} - Time since pageload ${performance.now().toFixed(0)}ms`);
                // We'll use the first onsize callback as an indication that video has started
                // playing out.
                if (startTime) {
                    const elapsedTime = window.performance.now() - startTime;
                    console.log('Setup time: ' + elapsedTime.toFixed(3) + 'ms');
                    startTime = null;
                }
            });
            function gotRemoteStream(e) {
                if (remotevideo.srcObject !== e.streams[0]) {
                    remotevideo.srcObject = e.streams[0];
                    console.log('received remote stream');
                }
            }
            function handleSuccess(stream) {
                startTime = window.performance.now();
                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length === 1) {
                    localStream = stream;
                    // localvideo.srcObject = localStream;
                    //localvideo.play();
                    const videoTracks = localStream.getVideoTracks();
                    const audioTracks = localStream.getAudioTracks();
                    if (videoTracks.length > 0) {
                        console.log(`Using video device: ${videoTracks[0].label}`);
                    }
                    if (audioTracks.length > 0) {
                        console.log(`Using audio device: ${audioTracks[0].label}`);
                    }
                    localStream.oninactive = () => {
                        console.log('Stream inactive:', localStream);
                    };

                    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                    console.log('Adding Local Stream to peer connection');
                } else {
                        console.log('The media stream contains an invalid number of audio tracks.');
                        localStream.getTracks().forEach(track => track.stop());
                }
            }

            function handleFailure(error) {
                console.log(`Failed to get access to local media. Error: ${error.name}`);
            }
            initButton.onclick = async () => {
                initButton.disabled = true;
                startButton.disabled = false;
                const options = {
                    keepalive: 30,
                    protocolId: 'MQTT',
                    protocolVersion: 4,
                    clean: true, // retain session
                    reconnectPeriod: 1000,
                    connectTimeout: 30 * 1000,
                    // Authentication information
                    clientId: local_view.value,
                    // username: 'nanmu0001',
                    // password: 'nanmu0001!@#$%',
                    username: '15JEvX-2Q3rY3Uk-7C:DF:A1:FF:FF:FF',
                    password: 's/Y5FosgfCvBL+24d8n5E6aR3gcnvBMtZvO+QI/3ehltHJc65wlIrCCfb2qJ4fHL',
                    will: {
                        topic: 'WillMsg',
                        payload: 'Connection Closed abnormally..!',
                        qos: 0,
                        retain: false
                    },
                    rejectUnauthorized: false
                }

                console.log('connecting mqtt client')
                client = mqtt.connect(host, options)

                client.on('error', (err) => {
                    console.log('Connection error: ', err)
                    client.end()
                })

                client.on('reconnect', () => {
                    console.log('Reconnecting...')
                })

                client.on('connect', () => {
                    console.log(local_view.value + ' connected mqtt:' + host)
                    client.subscribe(webrtc_topic_prefix + local_view.value, { qos: 0 })
                    console.log('subscribe: ' + webrtc_topic_prefix + local_view.value)
                    console.log('publish: ' + webrtc_topic_prefix + remote_view.value)
                })

                client.on('message', (topic, message, packet) => {
                    console.log('Received Message: ' + message.toString() + '\nOn topic: ' + topic)
                    obj = JSON.parse(message.toString());
                    switch (obj.type) {
                        case 'offer':
                            handleOffer(obj);
                            break;
                        case 'answer':
                            handleAnswer(obj);
                            break;
                        case 'candidate':
                            handleCandidate(obj);
                            break;
                        case 'ready':
                            // A second tab joined. This tab will enable the start button unless in a call already.
                            if (pc) {
                                console.log('already in call, ignoring');
                                return;
                            }
                            startButton.disabled = false;
                            break;
                        case 'bye':
                            if (pc) {
                                hangup();
                            }
                            break;
                        default:
                            console.log('unhandled', e);
                            break;
                    }
                })

                client.on('close', () => {
                    console.log(local_view.value + ' disconnected')
                })
                await createPeerConnection();
            };

            switchButton.onclick = async () => {
                var value = local_view.value
                local_view.value = remote_view.value
                remote_view.value = value
            };

            function onCreateSessionDescriptionError(error) {
                console.log(`Failed to create session description: ${error.toString()}`);
            }

            function onSetSessionDescriptionError(error) {
                console.log(`Failed to set session description: ${error.toString()}`);
            }

            function fmtp_filter(item) {
                item.config.search('level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f') != -1
            }
            function onCreateOfferSuccess(desc) {
                console.log(`Offer from pc\n${desc.sdp}`);
                res = sdpTransform.parse(desc.sdp);
                delete res.extmapAllowMixed
                // audio
                delete res.media[0].ext
                delete res.media[0].rtcpFb
                delete res.media[0].fmtp
                delete res.media[0].msid
                delete res.media[0].ssrcs
                res.media[0].rtp = res.media[0].rtp.filter(v=>v.codec=='PCMA')
                payloads = res.media[0].rtp.map((item) => item.payload)
                res.media[0].payloads = payloads.join(' ')

                //video
                delete res.media[1].ext
                // res.media[1].rtp = res.media[1].rtp.filter(v=>v.codec=='H264')
                fmtp = res.media[1].fmtp.filter(item=>item.config.search('level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f') != -1)
                p = fmtp.map((item) => item.payload)[0]
                payloads = [p, p+1]
                res.media[1].fmtp= res.media[1].fmtp.filter(item=>payloads.includes(item.payload))
                res.media[1].rtcpFb= res.media[1].rtcpFb.filter(item=>payloads.includes(item.payload))
                res.media[1].rtp= res.media[1].rtp.filter(item=>payloads.includes(item.payload))
                res.media[1].payloads = payloads.join(' ')
                offer_sdp = sdpTransform.write(res);
                console.log(`Offer filter\n${offer_sdp}`);
                console.log('pc setLocalDescription start');
                pc.setLocalDescription(desc).then(() => onSetLocalSuccess(pc), onSetSessionDescriptionError);
                // console.log({ type: 'offer', sdp: offer.sdp })
                remote_PostMessage({ type: 'offer', sdp: offer_sdp, client: local_view.value});
            }
            function onSetLocalSuccess(pc) {
                console.log(`pc setLocalDescription complete`);
            }

            function onSetRemoteSuccess(pc) {
                console.log(`pc setRemoteDescription complete`);
            }
            startButton.onclick = async () => {
                startButton.disabled = true;
                closeButton.disabled = false;

                // sendChannel = pc.createDataChannel('sendDataChannel');
                // sendChannel.onopen = onSendChannelStateChange;
                // sendChannel.onmessage = onSendChannelMessageCallback;
                // sendChannel.onclose = onSendChannelStateChange;
                console.log('createOffer start');
                pc.createOffer(offerOptions).then(onCreateOfferSuccess, onCreateSessionDescriptionError);
                // const offer = await pc.createOffer(offerOptions);
                // const offer = await pc.createOffer();
            };

            closeButton.onclick = async () => {
                hangup();
                remote_PostMessage({ type: 'bye' });
            };
            // setSdpButton.onclick = async () => {
            //     obj = JSON.parse(sdp_receive.value);
            //     handleAnswer(obj);
            // };
            async function hangup() {
                if (pc) {
                    pc.close();
                    pc = null;
                }
                sendChannel = null;
                receiveChannel = null;
                console.log('Closed peer connections');
                startButton.disabled = false;
                sendButton.disabled = true;
                closeButton.disabled = true;
                dataChannelSend.value = '';
                dataChannelReceive.value = '';
                dataChannelSend.disabled = true;
            };
            function createPeerConnection() {
                pc = new RTCPeerConnection(configuration);

                console.log('Requesting local stream');
                navigator.mediaDevices
                    .getUserMedia(constraints)
                    .then(handleSuccess)
                    .catch(handleFailure);

                pc.onicecandidate = e => {
                    const message = {
                        type: 'candidate',
                        candidate: null,
                    };
                    if (e.candidate) {
                        message.candidate = e.candidate.candidate;
                        message.sdpMid = e.candidate.sdpMid;
                        message.sdpMLineIndex = e.candidate.sdpMLineIndex;
                    }
                    remote_PostMessage(message);
                };

                pc.addEventListener('track', gotRemoteStream);
                // pc.ontrack = handleRemoteVideo;
                // pc.ontrack = (e) => {
                //     // remotevideo.srcObject = e.streams[0];
                //     // remotevideo.play();
                //     // hangupButton.disabled = false;
                //     // return false;
                //     if (remotevideo.srcObject !== event.streams[0]) {
                //         // remotevideo.srcObject = event.streams[0];
                //         // remotevideo.srcObject.getTracks().forEach(track => remotevideo.srcObject.addTrack(track, event.streams[0]));
                //         console.log('ontrack remote', event);
                //     }
                // };
                // pc.addEventListener('track', async (event) => {
                //     console.log('ontrack remote');
                //     const [remoteStream] = event.streams;
                // //     remotevideo.srcObject = e.streams[0];
                //     remotevideo.play()
                // });
            }

            async function handleOffer(offer) {
                // if (pc) {
                //     console.error('existing peerconnection');
                //     return;
                // }
                // await createPeerConnection();
                pc.ondatachannel = receiveChannelCallback;
                await pc.setRemoteDescription(offer);
                const answer = await pc.createAnswer();
                remote_PostMessage({ type: 'answer', sdp: answer.sdp });
                await pc.setLocalDescription(answer);
            }

            async function handleAnswer(answer) {
                if (!pc) {
                    console.error('no peerconnection');
                    return;
                }
                await pc.setRemoteDescription(answer);
            }

            async function handleCandidate(candidate) {
                if (!pc) {
                    console.error('no peerconnection');
                    return;
                }
                if (!candidate.candidate) {
                    await pc.addIceCandidate(null);
                } else {
                    await pc.addIceCandidate(candidate);
                }
            }

            function sendData() {
                const data = dataChannelSend.value;
                if (sendChannel) {
                    sendChannel.send(data);
                } else {
                    receiveChannel.send(data);
                }
                console.log('Sent Data: ' + data);
            }

            function receiveChannelCallback(event) {
                console.log('Receive Channel Callback');
                receiveChannel = event.channel;
                receiveChannel.onmessage = onReceiveChannelMessageCallback;
                receiveChannel.onopen = onReceiveChannelStateChange;
                receiveChannel.onclose = onReceiveChannelStateChange;
            }

            function onReceiveChannelMessageCallback(event) {
                console.log('Received Message' + event.data);
                dataChannelReceive.value = event.data;
            }

            function onSendChannelMessageCallback(event) {
                console.log('Received Message' + event.data);
                dataChannelReceive.value = event.data;
            }

            function onSendChannelStateChange() {
                const readyState = sendChannel.readyState;
                console.log('Send channel state is: ' + readyState);
                if (readyState === 'open') {
                    dataChannelSend.disabled = false;
                    dataChannelSend.focus();
                    sendButton.disabled = false;
                    startButton.disabled = true;
                    closeButton.disabled = false;
                } else {
                    dataChannelSend.disabled = true;
                    sendButton.disabled = true;
                    startButton.disabled = false;
                    closeButton.disabled = true;
                }
            }

            function onReceiveChannelStateChange() {
                const readyState = receiveChannel.readyState;
                console.log(`Receive channel state is: ${readyState}`);
                if (readyState === 'open') {
                    dataChannelSend.disabled = false;
                    sendButton.disabled = false;
                    closeButton.disabled = false;
                } else {
                    dataChannelSend.disabled = true;
                    sendButton.disabled = true;
                    closeButton.disabled = true;
                }
            }

        </script>
</body>

</html>